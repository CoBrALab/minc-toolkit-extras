#!/bin/bash

#
# ARG_OPTIONAL_SINGLE([colourmap],[],[Colour map name, or FILE to colourize objects, provide comma-separated pair for negative,positive map. See 'colour_object' for built in options.],[spectral])
# ARG_OPTIONAL_SINGLE([left-statmap],[],[Statistical map file to use for left object, use ":columnname" or ":columnnumber" to select column.],[])
# ARG_OPTIONAL_SINGLE([right-statmap],[],[Statistical map file to use for left object, use ":columnname" or ":columnnumber" to select column.],[])
# ARG_OPTIONAL_SINGLE([left-thresholds],[],[Comma separated thresholds which map statmap to colourmap, absolute values will be used on negative and positive side for diverging colourmaps, MIN and MAX to use detected data range.],[MIN,MAX])
# ARG_OPTIONAL_SINGLE([right-thresholds],[],[Comma separated thresholds which map statmap to colourmap, absolute values will be used on negative and positive side for diverging colourmaps, MIN and MAX to use detected data range.],[MIN,MAX])
# ARG_OPTIONAL_SINGLE([left-mask],[],[Binary mask file of same length as statmaps, which will be used to zero-out regions which should be excluded.],[])
# ARG_OPTIONAL_SINGLE([right-mask],[],[Binary mask file of same length as statmaps, which will be used to zero-out regions which should be excluded.],[])
# ARG_OPTIONAL_SINGLE([colourbar-labels],[],[Comma separated set of text labels which will be printed next to colourbar.],[FDR 5%,FDR 1%])
# ARG_OPTIONAL_SINGLE([image-label],[],[Label placed at the top of the image, defaults to column name of left statmap.],[LEFT_COLUMN])
# ARG_OPTIONAL_BOOLEAN([annotate-directions],[],[Label anatomical directions in image.],[on])
# ARG_OPTIONAL_BOOLEAN([draw-colourbar],[],[Draw colourbar on image.],[on])
# ARG_POSITIONAL_SINGLE([left-obj],[The left object file.])
# ARG_POSITIONAL_SINGLE([right-obj],[The right object file.])
# ARG_POSITIONAL_SINGLE([output],[The filename for the output image.])
# ARG_HELP([Colourize MNI objects with statistical maps])
# ARG_OPTIONAL_BOOLEAN([debug],[d],[Show all internal comands and logic for debug.],[])
# ARGBASH_SET_INDENT([  ])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


die()
{
  local _ret="${2:-1}"
  test "${_PRINT_HELP:-no}" = yes && print_help >&2
  echo "$1" >&2
  exit "${_ret}"
}


begins_with_short_option()
{
  local first_option all_short_options='hd'
  first_option="${1:0:1}"
  test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_colourmap="spectral"
_arg_left_statmap=
_arg_right_statmap=
_arg_left_thresholds="MIN,MAX"
_arg_right_thresholds="MIN,MAX"
_arg_left_mask=
_arg_right_mask=
_arg_colourbar_labels="FDR 5%,FDR 1%"
_arg_image_label="LEFT_COLUMN"
_arg_annotate_directions="on"
_arg_draw_colourbar="on"
_arg_debug="off"


print_help()
{
  printf '%s\n' "Colourize MNI objects with statistical maps"
  printf 'Usage: %s [--colourmap <arg>] [--left-statmap <arg>] [--right-statmap <arg>] [--left-thresholds <arg>] [--right-thresholds <arg>] [--left-mask <arg>] [--right-mask <arg>] [--colourbar-labels <arg>] [--image-label <arg>] [--(no-)annotate-directions] [--(no-)draw-colourbar] [-h|--help] [-d|--(no-)debug] <left-obj> <right-obj> <output>\n' "$0"
  printf '\t%s\n' "<left-obj>: The left object file."
  printf '\t%s\n' "<right-obj>: The right object file."
  printf '\t%s\n' "<output>: The filename for the output image."
  printf '\t%s\n' "--colourmap: Colour map name, or FILE to colourize objects, provide comma-separated pair for negative,positive map. See 'colour_object' for built in options. (default: 'spectral')"
  printf '\t%s\n' "--left-statmap: Statistical map file to use for left object, use \":columnname\" or \":columnnumber\" to select column. (no default)"
  printf '\t%s\n' "--right-statmap: Statistical map file to use for left object, use \":columnname\" or \":columnnumber\" to select column. (no default)"
  printf '\t%s\n' "--left-thresholds: Comma separated thresholds which map statmap to colourmap, absolute values will be used on negative and positive side for diverging colourmaps, MIN and MAX to use detected data range. (default: 'MIN,MAX')"
  printf '\t%s\n' "--right-thresholds: Comma separated thresholds which map statmap to colourmap, absolute values will be used on negative and positive side for diverging colourmaps, MIN and MAX to use detected data range. (default: 'MIN,MAX')"
  printf '\t%s\n' "--left-mask: Binary mask file of same length as statmaps, which will be used to zero-out regions which should be excluded. (no default)"
  printf '\t%s\n' "--right-mask: Binary mask file of same length as statmaps, which will be used to zero-out regions which should be excluded. (no default)"
  printf '\t%s\n' "--colourbar-labels: Comma separated set of text labels which will be printed next to colourbar. (default: 'FDR 5%,FDR 1%')"
  printf '\t%s\n' "--image-label: Label placed at the top of the image, defaults to column name of left statmap. (default: 'LEFT_COLUMN')"
  printf '\t%s\n' "--annotate-directions, --no-annotate-directions: Label anatomical directions in image. (on by default)"
  printf '\t%s\n' "--draw-colourbar, --no-draw-colourbar: Draw colourbar on image. (on by default)"
  printf '\t%s\n' "-h, --help: Prints help"
  printf '\t%s\n' "-d, --debug, --no-debug: Show all internal comands and logic for debug. (off by default)"
}


parse_commandline()
{
  _positionals_count=0
  while test $# -gt 0
  do
    _key="$1"
    case "$_key" in
      --colourmap)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_colourmap="$2"
        shift
        ;;
      --colourmap=*)
        _arg_colourmap="${_key##--colourmap=}"
        ;;
      --left-statmap)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_left_statmap="$2"
        shift
        ;;
      --left-statmap=*)
        _arg_left_statmap="${_key##--left-statmap=}"
        ;;
      --right-statmap)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_right_statmap="$2"
        shift
        ;;
      --right-statmap=*)
        _arg_right_statmap="${_key##--right-statmap=}"
        ;;
      --left-thresholds)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_left_thresholds="$2"
        shift
        ;;
      --left-thresholds=*)
        _arg_left_thresholds="${_key##--left-thresholds=}"
        ;;
      --right-thresholds)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_right_thresholds="$2"
        shift
        ;;
      --right-thresholds=*)
        _arg_right_thresholds="${_key##--right-thresholds=}"
        ;;
      --left-mask)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_left_mask="$2"
        shift
        ;;
      --left-mask=*)
        _arg_left_mask="${_key##--left-mask=}"
        ;;
      --right-mask)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_right_mask="$2"
        shift
        ;;
      --right-mask=*)
        _arg_right_mask="${_key##--right-mask=}"
        ;;
      --colourbar-labels)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_colourbar_labels="$2"
        shift
        ;;
      --colourbar-labels=*)
        _arg_colourbar_labels="${_key##--colourbar-labels=}"
        ;;
      --image-label)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_image_label="$2"
        shift
        ;;
      --image-label=*)
        _arg_image_label="${_key##--image-label=}"
        ;;
      --no-annotate-directions|--annotate-directions)
        _arg_annotate_directions="on"
        test "${1:0:5}" = "--no-" && _arg_annotate_directions="off"
        ;;
      --no-draw-colourbar|--draw-colourbar)
        _arg_draw_colourbar="on"
        test "${1:0:5}" = "--no-" && _arg_draw_colourbar="off"
        ;;
      -h|--help)
        print_help
        exit 0
        ;;
      -h*)
        print_help
        exit 0
        ;;
      -d|--no-debug|--debug)
        _arg_debug="on"
        test "${1:0:5}" = "--no-" && _arg_debug="off"
        ;;
      -d*)
        _arg_debug="on"
        _next="${_key##-d}"
        if test -n "$_next" -a "$_next" != "$_key"
        then
          { begins_with_short_option "$_next" && shift && set -- "-d" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
        fi
        ;;
      *)
        _last_positional="$1"
        _positionals+=("$_last_positional")
        _positionals_count=$((_positionals_count + 1))
        ;;
    esac
    shift
  done
}


handle_passed_args_count()
{
  local _required_args_string="'left-obj', 'right-obj' and 'output'"
  test "${_positionals_count}" -ge 3 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 3 (namely: $_required_args_string), but got only ${_positionals_count}." 1
  test "${_positionals_count}" -le 3 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 3 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
  local _positional_name _shift_for=$1
  _positional_names="_arg_left_obj _arg_right_obj _arg_output "

  shift "$_shift_for"
  for _positional_name in ${_positional_names}
  do
    test $# -gt 0 || break
    eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
    shift
  done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


awkscriptcsv='BEGIN{
  OFS=FS=","
  split(target, t_targets, ",")
  for (i in t_targets)
  targets[t_targets[i]] = i
}
NR==1 {
  for (i = 1; i <= NF; i++) head[i] = gensub(/\"/,  "", "g", $i)
}

NR !=1{
  for (i = 1; i <= NF; i++) {
    if (head[i] in targets){
      print $i
    }
  }
}'

awkscriptvertstats='BEGIN{
  OFS=FS=" "
  split(target, t_targets, ",")
  for (i in t_targets)
  targets[t_targets[i]] = i
}
NR==3 {
  for (i = 1; i <= NF; i++) head[i] = $i
}

NR >3{
  for (i = 1; i <= NF; i++) {
    if (head[i] in targets){
      print $i
    }
  }
}'


create_bar_graph=$(cat <<'EOF'
#! /usr/bin/env perl
#
# Create a colour bar for a legend box.
#

use strict;
use warnings "all";
use Getopt::Tabular;
use File::Basename;
use File::Temp qw/ tempdir /;

my($Help, $Usage, $me);

my $min = 0;
my $max = 1.0;
my $colour_map = "spectral";
my $colour_map_file = undef;
my $bg = "black";
my $width = 50;
my $height = 6 * $width;

$me = &basename($0);

$Help = <<HELP;
| $me creates a colour bar for a legend box.
|
| Problems or comments should be sent to: claude\@bic.mni.mcgill.ca
HELP

$Usage = "Usage: $me [options] output.png\n".
         "       $me -help to list options\n\n";

my @opt_table = (
   ["-width", "float", 1, \$width, "width of bar image" ],
   ["-height", "float", 1, \$height, "height of bar image" ],
   ["-min", "float", 1, \$min, "minimum range (0-1)" ],
   ["-max", "float", 1, \$max, "maximum range (0-1)" ],
   ["-colour", "string", 1, \$colour_map,
      "colour map (choices are: gray, hot, hot_inv, cold_metal, cold_metal_inv," .
      "green_metal, green_metal_inv, lime_metal, lime_metal_inv," .
      "red_metal, red_metal_inv, purple_metal, purple_metal_inv," .
      "spectral, red, green, blue)" ],
   ["-usercc", "string", 1, \$colour_map_file,
      "user-defined colour map file" ],
   ["-bg", "string", 1, \$bg, "background colour" ]
   );

# Check arguments
&Getopt::Tabular::SetHelp($Help, $Usage);
&GetOptions (\@opt_table, \@ARGV) || exit 1;
die $Usage if(! ($#ARGV == 0));

my $outfile = shift(@ARGV);

# make tmpdir
my $tmpdir = &tempdir( "$me-XXXXXXXX", TMPDIR => 1, CLEANUP => 1 );

my $x_size = int $width + 0.5;    # round up
my $y_size = int $height + 0.5;

$min = $min * ( $y_size - 1 );
$max = $max * ( $y_size - 1 );

# first create the binary mnc file
my $i;
my @data = undef;
my $packstring = '';
for($i=0; $i<$y_size; $i++){
   $data[$i] = $i;
   $packstring .= 'f';
}
my $data = pack($packstring, @data);

open(FH, ">$tmpdir/tmp-float.raw");
for($i=0; $i<$x_size; $i++){
   syswrite(FH, $data);
}
close(FH);


# make minc file

&do_cmd( 'rawtominc', '-clobber', '-float',
         '-input', "$tmpdir/tmp-float.raw",
	 '-xstep', 1, '-ystep', 1, '-zstep', 1,
         '-xstart', 0, '-ystart', 0, '-zstart', 0,
         '-dimorder', 'xspace,yspace,zspace',
         "$tmpdir/bar.mnc", $x_size, $y_size, 1 );

# make .rgb bar image using ray_trace

my @colour_args = ();
if( defined $colour_map_file ) {
  push @colour_args, "-usercc";
  push @colour_args, $colour_map_file;
} else {
  push @colour_args, "-${colour_map}";
}

&do_cmd( 'make_slice', "$tmpdir/bar.mnc", "$tmpdir/slice.obj", 0, 0, 0, 0, 0, 1 );
&do_cmd( 'ray_trace', '-output', "$tmpdir/bar.rgb", '-light', '-bg', $bg,
         '-ortho', '-top', '-size', $x_size, $y_size, '-window_width', $x_size,
         @colour_args, $min, $max, "$tmpdir/bar.mnc", 0, 1,
         "$tmpdir/slice.obj" );

# convert from .rgb to .png

&do_cmd('convert', "$tmpdir/bar.rgb", $outfile );

sub do_cmd {
   system(@_) == 0 or die "Failed: @_\n";
}
EOF
)

set -euo pipefail

### BASH HELPER FUNCTIONS ###
# Stolen from https://github.com/kvz/bash3boilerplate

# Set magic variables for current file, directory, os, etc.
__dir="$(cd "$(dirname "${BASH_SOURCE[${__b3bp_tmp_source_idx:-0}]}")" && pwd)"
__file="${__dir}/$(basename "${BASH_SOURCE[${__b3bp_tmp_source_idx:-0}]}")"
__base="$(basename "${__file}" .sh)"
# shellcheck disable=SC2034,SC2015
__invocation="$(printf %q "${__file}")$( (($#)) && printf ' %q' "$@" || true)"
# Calculator for maths
calc() { awk "BEGIN{ print $* }"; }

if [[ ${_arg_debug} == "on" ]]; then
  LOG_LEVEL=7
  set -x
else
  LOG_LEVEL=6
fi

function __b3bp_log() {
  local log_level="${1}"
  shift

  # shellcheck disable=SC2034
  local color_debug="\\x1b[35m" #]
  # shellcheck disable=SC2034
  local color_info="\\x1b[32m" #]
  # shellcheck disable=SC2034
  local color_notice="\\x1b[34m" #]
  # shellcheck disable=SC2034
  local color_warning="\\x1b[33m" #]
  # shellcheck disable=SC2034
  local color_error="\\x1b[31m" #]
  # shellcheck disable=SC2034
  local color_critical="\\x1b[1;31m" #]
  # shellcheck disable=SC2034
  local color_alert="\\x1b[1;37;41m" #]
  # shellcheck disable=SC2034
  local color_failure="\\x1b[1;4;5;37;41m" #]

  local colorvar="color_${log_level}"

  local color="${!colorvar:-${color_error}}"
  local color_reset="\\x1b[0m" #]

  if [[ "${NO_COLOR:-}" = "true" ]] || { [[ "${TERM:-}" != "xterm"* ]] && [[ "${TERM:-}" != "screen"* ]]; } || [[ ! -t 2 ]]; then
    if [[ "${NO_COLOR:-}" != "false" ]]; then
      # Don't use colors on pipes or non-recognized terminals
      color=""
      color_reset=""
    fi
  fi

  # all remaining arguments are to be printed
  local log_line=""

  while IFS=$'\n' read -r log_line; do
    echo -e "$(date -u +"%Y-%m-%d %H:%M:%S UTC") ${color}$(printf "[%9s]" "${log_level}")${color_reset} ${log_line}" 1>&2
  done <<<"${@:-}"
}

function failure() {
  __b3bp_log failure "${@}"
  exit 1
}
function alert() {
  [[ "${LOG_LEVEL:-0}" -ge 1 ]] && __b3bp_log alert "${@}"
  true
}
function critical() {
  [[ "${LOG_LEVEL:-0}" -ge 2 ]] && __b3bp_log critical "${@}"
  true
}
function error() {
  [[ "${LOG_LEVEL:-0}" -ge 3 ]] && __b3bp_log error "${@}"
  true
}
function warning() {
  [[ "${LOG_LEVEL:-0}" -ge 4 ]] && __b3bp_log warning "${@}"
  true
}
function notice() {
  [[ "${LOG_LEVEL:-0}" -ge 5 ]] && __b3bp_log notice "${@}"
  true
}
function info() {
  [[ "${LOG_LEVEL:-0}" -ge 6 ]] && __b3bp_log info "${@}"
  true
}
function debug() {
  [[ "${LOG_LEVEL:-0}" -ge 7 ]] && __b3bp_log debug "${@}"
  true
}

# Add handler for failure to show where things went wrong
failure_handler() {
  local lineno=${1}
  local msg=${2}
  alert "Failed at ${lineno}: ${msg}"
}
trap 'failure_handler ${LINENO} "$BASH_COMMAND"' ERR

function run_smart {
  # Function runs the command it wraps if the file does not exist
  if [[ ! -s "$1" ]]; then
    "$2"
  fi
}

tmpdir=$(mktemp -d)

#Setup exit trap for cleanup, don't do if debug
function finish() {
    if [[ ${_arg_debug} == "off" ]]; then
        rm -rf "${tmpdir}"
    else
      warning "Debug enabled, temporary files at ${tmpdir} have not been cleaned up"
    fi
}
trap finish EXIT

# Prefight check for required programs
for program in awk convert colour_object ray_trace; do
  if ! command -v ${program} &>/dev/null; then
    failure "Required program ${program} not found!"
  fi
done

# Extract column from input files
column=${_arg_left_statmap#*:}
filename=${_arg_left_statmap%:*}
extension="${filename##*.}"

#Pick out column
case $extension in
  csv)
    awk -v target=${column} -f <(printf "$awkscriptcsv") ${filename} > ${tmpdir}/left
    ;;
  vertstats)
    awk -v target=${column} -f <(printf "$awkscriptvertstats") ${filename} > ${tmpdir}/left
    ;;
  txt)
    cut -d " " -f ${column} ${filename} > ${tmpdir}/left
    ;;
esac

column=${_arg_right_statmap#*:}
filename=${_arg_right_statmap%:*}
extension="${filename##*.}"

#Pick out column
case $extension in
  csv)
    awk -v target=${column} -f <(printf "$awkscriptcsv") ${filename} > ${tmpdir}/right
    ;;
  vertstats)
    awk -v target=${column} -f <(printf "$awkscriptvertstats") ${filename} > ${tmpdir}/right
    ;;
  txt)
    cut -d " " -f ${column} ${filename} > ${tmpdir}/right
    ;;
esac




# Extract colourmap option into an array

IFS=', ' read -r -a _arg_colourmap <<< "${_arg_colourmap}"

if [[  ${#_arg_colourmap[@]} == 2 ]]; then
  # Extract the threshold levels for left from option
  threshold_low=$(echo ${_arg_left_thresholds[@]} | cut -d, -f 1)
  threshold_high=$(echo ${_arg_left_thresholds[@]} | cut -d, -f 2)

  if [[ ${threshold_low} == "MIN" ]]; then
    threshold_low=$(awk 'function abs(x) { return ( (x < 0) ? -x : x ) } { print abs($0) }' ${tmpdir}/left | sort -g | head -1 || true)
  fi

  if [[ ${threshold_high} == "MAX" ]]; then
    threshold_high=$(awk 'function abs(x) { return ( (x < 0) ? -x : x ) } { print abs($0) }' ${tmpdir}/left | sort -g | tail -1 || true)
  fi

  if [[ -s ${_arg_colourmap[0]} ]]; then
    colourmap="user ${_arg_colourmap[0]}"
  else
    colourmap="${_arg_colourmap[0]}"
  fi

  colour_object ${_arg_left_obj} ${tmpdir}/left ${tmpdir}/left_negative.obj ${colourmap} -${threshold_low} -${threshold_high} white

  if [[ -s ${_arg_colourmap[1]} ]]; then
    colourmap="user ${_arg_colourmap[1]}"
  else
    colourmap="${_arg_colourmap[1]}"
  fi
  colour_object ${tmpdir}/left_negative.obj ${tmpdir}/left ${tmpdir}/left_unmasked.obj ${colourmap} ${threshold_low} ${threshold_high} transparent transparent

  # Extract the threshold levels for left from option
  threshold_low=$(echo ${_arg_left_thresholds[@]} | cut -d, -f 1)
  threshold_high=$(echo ${_arg_left_thresholds[@]} | cut -d, -f 2)

  if [[ ${threshold_low} == "MIN" ]]; then
    threshold_low=$(awk 'function abs(x) { return ( (x < 0) ? -x : x ) } { print abs($0) }' ${tmpdir}/right | sort -g | head -1 || true)
  fi

  if [[ ${threshold_high} == "MAX" ]]; then
    threshold_high=$(awk 'function abs(x) { return ( (x < 0) ? -x : x ) } { print abs($0) }' ${tmpdir}/right | sort -g | tail -1 || true)
  fi

  if [[ -s ${_arg_colourmap[0]} ]]; then
    colourmap="user ${_arg_colourmap[0]}"
  else
    colourmap="${_arg_colourmap[0]}"
  fi

  colour_object ${_arg_right_obj} ${tmpdir}/right ${tmpdir}/right_negative.obj ${colourmap} -${threshold_low} -${threshold_high} white

  if [[ -s ${_arg_colourmap[1]} ]]; then
    colourmap="user ${_arg_colourmap[1]}"
  else
    colourmap="${_arg_colourmap[1]}"
  fi
  colour_object ${tmpdir}/right_negative.obj ${tmpdir}/right ${tmpdir}/right_unmasked.obj ${colourmap} ${threshold_low} ${threshold_high} transparent transparent

else

  if [[ -s ${_arg_colourmap[0]} ]]; then
    colourmap="user ${_arg_colourmap[0]}"
  else
    colourmap="${_arg_colourmap[0]}"
  fi

  # Extract the threshold levels for left from option
  threshold_low=$(echo ${_arg_left_thresholds[@]} | cut -d, -f 1)
  threshold_high=$(echo ${_arg_left_thresholds[@]} | cut -d, -f 2)

  if [[ ${threshold_low} == "MIN" ]]; then
    threshold_low=$(sort -g ${tmpdir}/left | head -1 || true)
  fi

  if [[ ${threshold_high} == "MAX" ]]; then
    threshold_high=$(sort -g ${tmpdir}/left | tail -1 || true)
  fi

  colour_object ${_arg_left_obj} ${tmpdir}/left ${tmpdir}/left_unmasked.obj ${colourmap} ${threshold_low} ${threshold_high}

  # Extract the threshold levels for right from option
  threshold_low=$(echo ${_arg_right_thresholds[@]} | cut -d, -f 1)
  threshold_high=$(echo ${_arg_right_thresholds[@]} | cut -d, -f 2)

  if [[ ${threshold_low} == "MIN" ]]; then
    threshold_low=$(sort -g ${tmpdir}/right | head -1 || true)
  fi

  if [[ ${threshold_high} == "MAX" ]]; then
    threshold_high=$(sort -g ${tmpdir}/right | tail -1 || true)
  fi

  colour_object ${_arg_right_obj} ${tmpdir}/right ${tmpdir}/right_unmasked.obj ${colourmap} ${threshold_low} ${threshold_high}
fi

if [[ -s ${_arg_left_mask} ]]; then
  colour_object ${tmpdir}/left_unmasked.obj ${_arg_left_mask} ${tmpdir}/left_final.obj gray 0.5 0.5 white transparent
else
  cp -s ${tmpdir}/left_unmasked.obj ${tmpdir}/left_final.obj
fi

if [[ -s ${_arg_right_mask} ]]; then
  colour_object ${tmpdir}/right_unmasked.obj ${_arg_right_mask} ${tmpdir}/right_final.obj gray 0.5 0.5 white transparent
else
  cp -s ${tmpdir}/right_unmasked.obj ${tmpdir}/right_final.obj
fi

# Generate views
echo """ray_trace -output ${tmpdir}/inferior.rgb ${tmpdir}/left_final.obj ${tmpdir}/right_final.obj -size 1000 1000 -crop -sup 3 -bg black -bottom -directional 1 -1 -1 1 1 1 -directional -1 -1 -1 1 1 1 -directional -1 -1 1 1 1 1
ray_trace -output ${tmpdir}/superior.rgb ${tmpdir}/left_final.obj ${tmpdir}/right_final.obj -size 1000 1000 -crop -sup 3 -bg black -top -shadows -directional 1 -1 -1 1 1 1 -directional -1 -1 -1 1 1 1 -directional -1 -1 1 1 1 1
ray_trace -output ${tmpdir}/anterior.rgb ${tmpdir}/left_final.obj ${tmpdir}/right_final.obj -size 1000 1000 -crop -sup 3 -bg black -front -shadows -directional 1 -1 -1 1 1 1 -directional -1 -1 -1 1 1 1 -directional -1 -1 1 1 1 1
ray_trace -output ${tmpdir}/posterior.rgb ${tmpdir}/left_final.obj ${tmpdir}/right_final.obj -size 1000 1000 -crop -sup 3 -bg black -back -shadows -directional 1 -1 -1 1 1 1 -directional -1 -1 -1 1 1 1 -directional -1 -1 1 1 1 1
ray_trace -output ${tmpdir}/left_medial.rgb ${tmpdir}/left_final.obj -size 1000 1000 -crop -sup 3 -bg black -right -shadows -directional 1 -1 -1 1 1 1 -directional -1 -1 -1 1 1 1 -directional -1 -1 1 1 1 1
ray_trace -output ${tmpdir}/left_lateral.rgb ${tmpdir}/left_final.obj -size 1000 1000 -crop -sup 3 -bg black -left -shadows -directional 1 -1 -1 1 1 1 -directional -1 -1 -1 1 1 1 -directional -1 -1 1 1 1 1
ray_trace -output ${tmpdir}/right_medial.rgb ${tmpdir}/right_final.obj -size 1000 1000 -crop -sup 3 -bg black -left -shadows -directional 1 -1 -1 1 1 1 -directional -1 -1 -1 1 1 1 -directional -1 -1 1 1 1 1
ray_trace -output ${tmpdir}/right_lateral.rgb ${tmpdir}/right_final.obj -size 1000 1000 -crop -sup 3 -bg black  -right -shadows -directional 1 -1 -1 1 1 1 -directional -1 -1 -1 1 1 1 -directional -1 -1 1 1 1 1""" | parallel

# Add anatomical directions to images
for file in ${tmpdir}/*rgb; do
    if [[ ${_arg_annotate_directions} == "on" ]]; then
      convert ${file} -stroke white -strokewidth 2 -fill black -pointsize 50 -gravity south -annotate 0 "$(basename ${file} .rgb | sed 's/_/ /g')" ${tmpdir}/$(basename ${file} .rgb)_annotated.mpc
    else
      convert ${file} ${tmpdir}/$(basename ${file} .rgb)_annotated.mpc
    fi
done

# Generation of diverging on single-sided colourbar
if [[  ${#_arg_colourmap[@]} == 2 ]]; then
  if [[ -s ${_arg_colourmap[0]} ]]; then
    perl -e "${create_bar_graph}" -- -width 30 -height 300 -min 1 -max 0 -usercc ${_arg_colourmap[0]} ${tmpdir}/colourbar_neg.png
  else
    perl -e "${create_bar_graph}" -- -width 30 -height 300 -min 1 -max 0 -colour ${_arg_colourmap[0]} ${tmpdir}/colourbar_neg.png
  fi

  if [[ -s ${_arg_colourmap[1]} ]]; then
    perl -e "${create_bar_graph}" -- -width 30 -height 300 -usercc ${_arg_colourmap[1]} ${tmpdir}/colourbar_pos.png
  else
    perl -e "${create_bar_graph}" -- -width 30 -height 300 -colour ${_arg_colourmap[1]} ${tmpdir}/colourbar_pos.png
  fi

  convert ${tmpdir}/colourbar_pos.png ${tmpdir}/colourbar_neg.png -append ${tmpdir}/colourbar.png

  if [[ -n ${_arg_colourbar_labels} ]]; then
    colourbar_label_low=(-gravity SouthWest -annotate +1400+290 "$(echo ${_arg_colourbar_labels} | cut -d, -f 1)")
    colourbar_label_high=(-gravity SouthWest -annotate +1400+580 "$(echo ${_arg_colourbar_labels} | cut -d, -f 2)")
    colourbar_label_high+=(-gravity SouthWest -annotate +1400+12 "$(echo ${_arg_colourbar_labels} | cut -d, -f 2)")
  fi
else
  if [[ -s ${_arg_colourmap[0]} ]]; then
    perl -e "${create_bar_graph}" -- -width 30 -height 600 -usercc ${_arg_colourmap[0]} ${tmpdir}/colourbar.png
  else
    perl -e "${create_bar_graph}" -- -width 30 -height 600 -colour ${_arg_colourmap[0]} ${tmpdir}/colourbar.png
  fi

  if [[ -n ${_arg_colourbar_labels} ]]; then
    colourbar_label_low=(-gravity SouthWest -annotate +1400+12 "$(echo ${_arg_colourbar_labels} | cut -d, -f 1)")
    colourbar_label_high=(-gravity SouthWest -annotate +1400+580 "$(echo ${_arg_colourbar_labels} | cut -d, -f 2)")
  fi
fi

# Should we draw colourbar and colourbar annotation?
if [[ ${_arg_draw_colourbar} == "on" ]]; then
  colourbar_draw="-page +1354+1720 ${tmpdir}/colourbar.png -bordercolor black -border 2x2 -bordercolor white -border 2x2 "
else
  colourbar_draw=""
  colourbar_label_low=()
  colourbar_label_high=()
fi

# Draw a label
if [[ -n ${_arg_image_label} ]]; then
  if [[ ${_arg_image_label} == "LEFT_COLUMN" ]]; then
    column=${_arg_left_statmap#*:}
    image_label="-gravity North -annotate 0 ${column}"
  else
    image_label="-gravity North -annotate 0 ${_arg_image_label}"
  fi
else
  image_label=""
fi

# Should we draw annotations on the image
if [[ ${_arg_annotate_directions} == "on" ]]; then
  annotate_si="""+repage -gravity west -annotate 0 L \
    -gravity east -annotate 0 L \
    -gravity center -annotate 0 R"""
  annotate_ap="""+repage  -gravity west -annotate 0 R \
    -gravity east -annotate 0 R \
    -gravity center -annotate 0 L"""
else
  annotate_si=""
  annotate_ap=""
fi

# Build final image
# - set font details
# - append layers of images
# - draw colourbar
# - draw colourbar annotations
convert -background black \
  -stroke white -strokewidth 2 -fill black -pointsize 50 \
  \( ${tmpdir}/left_medial_annotated.mpc ${tmpdir}/right_medial_annotated.mpc +append  \) \
  \( ${tmpdir}/left_lateral_annotated.mpc ${tmpdir}/right_lateral_annotated.mpc +append -gravity Center \) \
  \( ${tmpdir}/superior_annotated.mpc ${tmpdir}/inferior_annotated.mpc +append -gravity Center \
    ${annotate_si} \) \
  \( ${tmpdir}/anterior_annotated.mpc ${tmpdir}/posterior_annotated.mpc +append -gravity Center \
    ${annotate_ap} \) \
  -append +repage \
  ${colourbar_draw} \
  "${colourbar_label_low[@]}" \
  "${colourbar_label_high[@]}" \
  ${image_label} \
  -flatten ${tmpdir}/final.mpc

convert ${tmpdir}/final.mpc ${_arg_output}

# ] <-- needed because of Argbash
